<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>{% block title %}{% endblock %}</title>
  {% block favicon %}{% endblock %}
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
      margin: 10px;
      line-height: 1.3;
      background-color: #f6f8fa;
      font-size: 13px;
      color: #24292f;
    }
    .header {
      /* NVIDIA brand green (keep readable white text/links on top). */
      background-color: #76b900;
      color: white;
      padding: 10px 15px;
      border-radius: 4px;
      /* Keep pages visually tight: legend/content should sit close to the header. */
      margin-bottom: 4px;
    }
    .header a {
      color: #ffffff;
      text-decoration: none;
    }
    .header a:hover {
      text-decoration: underline;
    }
    .header h1 {
      margin: 0;
      font-size: 18px;
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
    }
    .header .header-meta {
      font-size: 12px;
      font-weight: 500;
      opacity: 0.95;
      white-space: nowrap;
    }

    /* Subtitle text in the header (keep high contrast against NVIDIA green). */
    .header .header-subtitle {
      margin: 5px 0 0 0;
      opacity: 1;
      color: #ffffff;
    }
    .header .header-subtitle .meta {
      opacity: 0.95;
      font-size: 12px;
    }
    .header .page-age {
      display: inline-block;
      margin-left: 6px;
      padding: 1px 8px;
      border-radius: 999px;
      /* Subtle chip: enough contrast on NVIDIA green without looking “loud”. */
      background: rgba(0, 0, 0, 0.16);
      color: #ffffff;
      font-weight: 600;
      font-size: 12px;
      line-height: 1.3;
      white-space: nowrap;
    }

    .footer {
      margin-top: 12px;
      padding: 10px 12px;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      background: #ffffff;
      color: #24292f;
    }
    .footer details summary {
      cursor: pointer;
      user-select: none;
      /* Make "Legend & Help" less conspicuous per UX request. */
      font-weight: 600;
      font-size: 12px;
      color: #57606a;
    }
    .footer details summary:hover {
      color: #0969da;
    }
    .footer details {
      color: #57606a;
      font-size: 12px;
    }

    /* Legend/Help blocks embedded near the top of dashboards (not the footer). */
    .legend details summary {
      cursor: pointer;
      user-select: none;
      font-weight: 600;
      font-size: 12px;
      color: #57606a;
    }
    .legend details {
      color: #57606a;
      font-size: 12px;
    }
    .stats-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      font-size: 12px;
    }
    .stats-table td {
      padding: 6px 8px;
      border-top: 1px solid #d8dee4;
      vertical-align: top;
    }
    .stats-table td.k {
      width: 220px;
      color: #57606a;
      font-weight: 600;
      white-space: nowrap;
    }
    .stats-table td.v {
      color: #24292f;
      font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
      word-break: break-word;
    }
    .stats-table td.section {
      padding: 10px 8px 6px 8px;
      color: #24292f;
      font-weight: 700;
      background: #f6f8fa;
      border-top: 1px solid #d8dee4;
    }
    .stats-pre {
      margin: 0;
      white-space: pre-wrap;
      overflow-wrap: anywhere;
      word-break: break-word;
      font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
      font-size: 12px;
      line-height: 1.35;
    }

    {% block css %}{% endblock %}

    /* GitHub checks tooltip styling (static; shared across dashboards) */
    .gh-status-tooltip {
      position: relative;
      display: inline-block;
    }
    .gh-status-tooltip .tooltiptext {
      visibility: hidden;
      max-width: calc(100vw - 40px);
      background-color: #24292f;
      color: #ffffff;
      text-align: left;
      border-radius: 6px;
      padding: 8px 12px;
      position: fixed;
      z-index: 1000;
      left: 20px;
      right: 20px;
      width: auto;
      opacity: 0;
      transition: opacity 0.3s, visibility 0s 1s;
      font-size: 12px;
      line-height: 1.5;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      white-space: normal;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    .gh-status-tooltip .tooltiptext::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 20px;
      margin-left: -5px;
      border-width: 5px;
      border-style: solid;
      border-color: #24292f transparent transparent transparent;
    }
    .gh-status-tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
      transition-delay: 1s;
    }

    /* Auto-refresh connection banner (sleep/wake fault tolerance) */
    .auto-refresh-banner {
      position: fixed;
      left: 10px;
      right: 10px;
      bottom: 10px;
      z-index: 9999;
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid #d0d7de;
      background: rgba(255, 255, 255, 0.96);
      color: #24292f;
      box-shadow: 0 4px 12px rgba(0,0,0,0.12);
      font-size: 12px;
      display: none;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .auto-refresh-banner .msg {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .auto-refresh-banner button {
      border: 1px solid #d0d7de;
      background: #f6f8fa;
      color: #24292f;
      border-radius: 8px;
      padding: 4px 10px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      white-space: nowrap;
    }
    .auto-refresh-banner button:hover {
      background: #eef1f4;
    }
  </style>

  {% block head_script %}{% endblock %}
</head>
<body>
  <div class="header">
    <h1>{% block header_title %}{% endblock %}</h1>
    {% block header_subtitle %}{% endblock %}
  </div>

  {% block content %}{% endblock %}

  {% if page_stats %}
  <div class="footer">
    <details data-url-state="1" data-url-key="stats">
      <summary>Statistics</summary>
      <table class="stats-table">
        {% for k, v in page_stats %}
        <tr>
          {% if v is none and (k|string)[:3] == '## ' %}
          <td class="section" colspan="2">{{ (k|string)[3:] }}</td>
          {% else %}
          <td class="k">{{ k }}</td>
          <td class="v">
            {% if v is string and '\n' in v %}
            <pre class="stats-pre">{{ v }}</pre>
            {% else %}
            {{ v }}
            {% endif %}
          </td>
          {% endif %}
        </tr>
        {% endfor %}
      </table>
    </details>
  </div>
  {% endif %}

  <script>
  // Position tooltips dynamically (static; shared)
  document.addEventListener('DOMContentLoaded', function() {
    var tooltips = document.querySelectorAll('.gh-status-tooltip');
    tooltips.forEach(function(tooltip) {
      tooltip.addEventListener('mouseenter', function() {
        var tooltipText = this.querySelector('.tooltiptext');
        if (!tooltipText) return;
        var rect = this.getBoundingClientRect();
        // Position tooltip above the element
        tooltipText.style.top = (rect.top - tooltipText.offsetHeight - 10) + 'px';
      });
    });
  });

  // Shared tree toggle JS (static; used by <pre>-tree output)
  function toggleTreeChildren(childrenId, toggleEl) {
    var el = document.getElementById(childrenId);
    if (!el) return;
    var hidden = (el.style.display === 'none' || el.style.display === '');
    el.style.display = hidden ? 'inline' : 'none';
    if (toggleEl) {
      toggleEl.textContent = hidden ? '▼' : '▶';
    }
    try {
      if (window.DashboardUrlState && typeof window.DashboardUrlState.setBool === 'function') {
        var defExp = false;
        try { defExp = (toggleEl && toggleEl.getAttribute('data-default-expanded') === '1'); } catch (e) {}
        var urlKey = '';
        try { urlKey = String((toggleEl && toggleEl.getAttribute('data-url-key')) || ''); } catch (e) { urlKey = ''; }
        if (!urlKey) {
          urlKey = 't.' + String(childrenId || '');
        }
        if (typeof window.DashboardUrlState.setBoolDefault === 'function') {
          window.DashboardUrlState.setBoolDefault(urlKey, hidden, defExp);
        } else {
          window.DashboardUrlState.setBool(urlKey, hidden);
        }
      }
    } catch (e) {}
  }

  // Shared "Snippet" toggle (used by [raw log] leaves)
  function toggleErrorSnippet(errorId, toggleEl) {
    var el = document.getElementById(errorId);
    if (!el) return;
    var hidden = (el.style.display === 'none' || el.style.display === '');
    el.style.display = hidden ? 'inline' : 'none';
    if (toggleEl) {
      toggleEl.textContent = hidden ? '▼ Hide snippet' : '▶ Snippet';
    }
    try {
      if (window.DashboardUrlState && typeof window.DashboardUrlState.setBool === 'function') {
        var defExp = false;
        try { defExp = (toggleEl && toggleEl.getAttribute('data-default-expanded') === '1'); } catch (e) {}
        var urlKey = '';
        try { urlKey = String((toggleEl && toggleEl.getAttribute('data-url-key')) || ''); } catch (e) { urlKey = ''; }
        if (!urlKey) {
          urlKey = 's.' + String(errorId || '');
        }
        if (typeof window.DashboardUrlState.setBoolDefault === 'function') {
          window.DashboardUrlState.setBoolDefault(urlKey, hidden, defExp);
        } else {
          window.DashboardUrlState.setBool(urlKey, hidden);
        }
      }
    } catch (e) {}
  }

  // Collapse snippet from the in-snippet "X" button (also resets toggle triangle + URL state).
  function collapseErrorSnippet(errorId) {
    var el = document.getElementById(errorId);
    if (!el) return;
    el.style.display = 'none';

    var toggleEl = document.getElementById(String(errorId || '') + '__toggle');
    if (!toggleEl) {
      try { toggleEl = document.querySelector('[data-error-id=\"' + String(errorId || '') + '\"]'); } catch (e) {}
    }
    if (toggleEl) {
      toggleEl.textContent = '▶ Snippet';
    }

    try {
      if (window.DashboardUrlState && typeof window.DashboardUrlState.setBool === 'function') {
        var defExp = false;
        try { defExp = (toggleEl && toggleEl.getAttribute('data-default-expanded') === '1'); } catch (e) {}
        var urlKey = '';
        try { urlKey = String((toggleEl && toggleEl.getAttribute('data-url-key')) || ''); } catch (e) { urlKey = ''; }
        if (!urlKey) {
          urlKey = 's.' + String(errorId || '');
        }
        if (typeof window.DashboardUrlState.setBoolDefault === 'function') {
          window.DashboardUrlState.setBoolDefault(urlKey, false, defExp);
        } else {
          window.DashboardUrlState.setBool(urlKey, false);
        }
      }
    } catch (e) {}
  }

  // Shared copy-to-clipboard helpers
  function copyToClipboard(text, button) {
    if (!text) return;
    var textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();

    try {
      var successful = document.execCommand('copy');
      document.body.removeChild(textArea);
      if (successful && button) {
        var originalHTML = button.innerHTML;
        // copy_icon_svg is HTML and may contain newlines/quotes; encode as JSON to avoid breaking JS parsing.
        var icon = {{ copy_icon_svg | default("") | tojson }};
        button.innerHTML = (icon ? icon : '') + '<span style="margin-left: 6px;">Copied!</span>';
        setTimeout(function() { button.innerHTML = originalHTML; }, 2000);
      }
    } catch (err) {
      document.body.removeChild(textArea);
    }
  }

  function copyFromClipboardAttr(button) {
    if (!button) return;
    var text = button.getAttribute('data-clipboard-text');
    if (!text) return;
    copyToClipboard(text, button);
  }

  // Calculate and display page age (shared)
  (function() {
    var el = document.getElementById('page-age');
    if (!el) return;
    const timeStr = '{{ generated_time | default("") }}';
    const timeStrFixed = timeStr.replace(' PST', '-08:00').replace(' PDT', '-07:00');
    const generatedTime = new Date(timeStrFixed);

    function updatePageAge() {
      if (isNaN(generatedTime.getTime())) {
        el.textContent = '(invalid date)';
        return;
      }
      const now = new Date();
      const ageMs = now - generatedTime;
      const seconds = Math.floor(ageMs / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      let ageText = '';
      if (days > 0) {
        ageText = `(${days} day${days > 1 ? 's' : ''} ${hours % 24} hour${(hours % 24) !== 1 ? 's' : ''} old)`;
      } else if (hours > 0) {
        ageText = `(${hours} hour${hours > 1 ? 's' : ''} ${minutes % 60} min old)`;
      } else if (minutes > 0) {
        ageText = `(${minutes} minute${minutes > 1 ? 's' : ''} old)`;
      } else {
        ageText = `(${seconds} second${seconds !== 1 ? 's' : ''} old)`;
      }

      el.textContent = ageText;
    }

    updatePageAge();
    setInterval(updatePageAge, 3000);
  })();

  // ====================================================================================
  // URL <-> UI state sync (shared)
  //
  // Goal: allow cut/paste of dashboard URLs that preserve view state:
  // - checkboxes / selects / <details> that opt-in via `data-url-state="1"`
  // - tree expansions/snippets via toggleTreeChildren()/toggleErrorSnippet()
  //
  // Storage:
  // - querystring (`?key=value`) using history.replaceState (no reload)
  // - also supports reading state from hash (`#key=value&...`) for convenience/back-compat
  // ====================================================================================
  (function() {
    function _parseParams() {
      var out = new URLSearchParams();
      try {
        var qs = new URLSearchParams(window.location.search || '');
        qs.forEach(function(v, k) { out.set(k, v); });
      } catch (e) {}
      try {
        var h = String(window.location.hash || '');
        if (h && h.indexOf('=') !== -1) {
          var hs = h.startsWith('#') ? h.slice(1) : h;
          var hp = new URLSearchParams(hs);
          hp.forEach(function(v, k) {
            if (!out.has(k)) out.set(k, v);
          });
        }
      } catch (e) {}
      return out;
    }

    function _isTruthyParam(v) {
      var s = String(v || '').trim().toLowerCase();
      return (s === '1' || s === 'true' || s === 'yes' || s === 'on' || s === 'open');
    }

    function _controlKey(el) {
      if (!el) return '';
      var k = el.getAttribute('data-url-key');
      if (k) return String(k);
      if (el.id) return String(el.id);
      var nm = el.getAttribute('name');
      if (nm) return String(nm);
      return '';
    }

    function _replaceUrl(params) {
      try {
        var url = new URL(window.location.href);
        // Preserve any existing non-state hash (anchors). If hash looks like state, prefer empty hash.
        var keepHash = '';
        var h = String(url.hash || '');
        if (h && h.indexOf('=') === -1) keepHash = h;
        url.search = params.toString() ? ('?' + params.toString()) : '';
        url.hash = keepHash;
        window.history.replaceState({}, '', url.toString());
      } catch (e) {}
    }

    var _defaults = {};
    var _restoring = false;

    function _captureDefaults() {
      var nodes = document.querySelectorAll('[data-url-state="1"]');
      nodes.forEach(function(el) {
        var key = _controlKey(el);
        if (!key) return;
        if (el.tagName && el.tagName.toLowerCase() === 'details') {
          _defaults[key] = el.open ? '1' : '0';
          return;
        }
        if (el.tagName && el.tagName.toLowerCase() === 'select') {
          _defaults[key] = String(el.value || '');
          return;
        }
        var t = (el.getAttribute('type') || '').toLowerCase();
        if (t === 'checkbox') {
          _defaults[key] = el.checked ? '1' : '0';
          return;
        }
      });
    }

    function _applyToControlsFromParams(params) {
      var nodes = document.querySelectorAll('[data-url-state="1"]');
      _restoring = true;
      try {
        nodes.forEach(function(el) {
          var key = _controlKey(el);
          if (!key) return;
          if (!params.has(key)) return;
          var v = params.get(key);
          if (el.tagName && el.tagName.toLowerCase() === 'details') {
            el.open = _isTruthyParam(v);
            // 'toggle' event is not reliably fired by setting `open` in all browsers; dispatch one.
            try { el.dispatchEvent(new Event('toggle')); } catch (e) {}
            return;
          }
          if (el.tagName && el.tagName.toLowerCase() === 'select') {
            el.value = String(v || '');
            try { el.dispatchEvent(new Event('change')); } catch (e) {}
            return;
          }
          var t = (el.getAttribute('type') || '').toLowerCase();
          if (t === 'checkbox') {
            el.checked = _isTruthyParam(v);
            try { el.dispatchEvent(new Event('change')); } catch (e) {}
            return;
          }
        });
      } finally {
        _restoring = false;
      }
    }

    function _bindControlsToUrl() {
      var nodes = document.querySelectorAll('[data-url-state="1"]');
      nodes.forEach(function(el) {
        var key = _controlKey(el);
        if (!key) return;
        var evt = 'change';
        if (el.tagName && el.tagName.toLowerCase() === 'details') evt = 'toggle';
        el.addEventListener(evt, function() {
          if (_restoring) return;
          var params = _parseParams();
          var val = '';
          if (el.tagName && el.tagName.toLowerCase() === 'details') {
            val = el.open ? '1' : '0';
          } else if (el.tagName && el.tagName.toLowerCase() === 'select') {
            val = String(el.value || '');
          } else {
            var t = (el.getAttribute('type') || '').toLowerCase();
            if (t === 'checkbox') {
              val = el.checked ? '1' : '0';
            }
          }
          // Remove param if it matches default (keeps URLs short/clean).
          if (_defaults.hasOwnProperty(key) && String(_defaults[key]) === String(val)) {
            params.delete(key);
          } else {
            params.set(key, String(val));
          }
          _replaceUrl(params);
        });
      });
    }

    function _applyTreeAndSnippetTogglesFromParams(params) {
      // Apply per-toggle URL keys (compact, SHA-first).
      try {
        // Tree nodes (triangles)
        var tris = document.querySelectorAll('[data-children-id][data-url-key]');
        tris.forEach(function(tg) {
          try {
            var urlKey = String(tg.getAttribute('data-url-key') || '');
            if (!urlKey || !params.has(urlKey)) return;
            var wantOpen = _isTruthyParam(params.get(urlKey));
            var cid = String(tg.getAttribute('data-children-id') || '');
            if (!cid) return;
            var el = document.getElementById(cid);
            if (!el) return;
            el.style.display = wantOpen ? 'inline' : 'none';
            tg.textContent = wantOpen ? '▼' : '▶';
          } catch (e) {}
        });

        // Snippets
        var snToggles = document.querySelectorAll('[data-error-id][data-url-key]');
        snToggles.forEach(function(tg) {
          try {
            var urlKey = String(tg.getAttribute('data-url-key') || '');
            if (!urlKey || !params.has(urlKey)) return;
            var wantOpen = _isTruthyParam(params.get(urlKey));
            var errId = String(tg.getAttribute('data-error-id') || '');
            if (!errId) return;
            var el = document.getElementById(errId);
            if (!el) return;
            el.style.display = wantOpen ? 'inline' : 'none';
            tg.textContent = wantOpen ? '▼ Hide snippet' : '▶ Snippet';
          } catch (e) {}
        });
      } catch (e) {}
    }

    window.DashboardUrlState = {
      get: function(key) {
        try { return _parseParams().get(String(key || '')); } catch (e) { return null; }
      },
      has: function(key) {
        try { return _parseParams().has(String(key || '')); } catch (e) { return false; }
      },
      set: function(key, value) {
        if (_restoring) return;
        try {
          var k = String(key || '');
          if (!k) return;
          var params = _parseParams();
          params.set(k, String(value == null ? '' : value));
          _replaceUrl(params);
        } catch (e) {}
      },
      setBool: function(key, boolVal) {
        if (_restoring) return;
        try {
          var k = String(key || '');
          if (!k) return;
          var params = _parseParams();
          params.set(k, boolVal ? '1' : '0');
          _replaceUrl(params);
        } catch (e) {}
      },
      // Like setBool(), but remove the key from the URL when the value matches the default.
      // This keeps URLs short and avoids `...?x=0` noise.
      setBoolDefault: function(key, boolVal, defaultVal) {
        if (_restoring) return;
        try {
          var k = String(key || '');
          if (!k) return;
          var params = _parseParams();
          var v = !!boolVal;
          var d = !!defaultVal;
          if (v === d) {
            params.delete(k);
          } else {
            params.set(k, v ? '1' : '0');
          }
          _replaceUrl(params);
        } catch (e) {}
      },
      resetView: function(opts) {
        // Remove known dashboard-state query params and restore defaults.
        // Default behavior reloads the page after clearing URL so non-control state (e.g. default-expanded trees)
        // is also restored.
        try {
          var o = opts || {};
          var doReload = (o.reload !== false);
          var params = _parseParams();

          // Remove dashboard state params.
          var toDelete = [];
          params.forEach(function(v, k) {
            var ks = String(k || '');
            if (!ks) return;
            if (ks === 'legend') { toDelete.push(ks); return; }
            if (ks === 'date.mode') { toDelete.push(ks); return; }
            if (ks.startsWith('col.')) { toDelete.push(ks); return; }
            if (ks.startsWith('t.')) { toDelete.push(ks); return; }      // tree toggles
            if (ks.startsWith('s.')) { toDelete.push(ks); return; }      // snippet toggles
            if (ks.startsWith('d.')) { toDelete.push(ks); return; }      // commit-history docker rows
            if (ks.startsWith('gh.')) { toDelete.push(ks); return; }     // commit-history github tree
            if (ks.startsWith('gl.')) { toDelete.push(ks); return; }     // commit-history gitlab tree
          });
          toDelete.forEach(function(k) { try { params.delete(k); } catch (e) {} });

          // Also remove any known control keys we recorded defaults for.
          try {
            Object.keys(_defaults || {}).forEach(function(k) {
              try { params.delete(String(k || '')); } catch (e) {}
            });
          } catch (e) {}

          _replaceUrl(params);

          if (doReload) {
            try { window.location.reload(); } catch (e) {}
          } else {
            // Best-effort restore of known controls without reload.
            _restoring = true;
            try {
              var nodes = document.querySelectorAll('[data-url-state="1"]');
              nodes.forEach(function(el) {
                var key = _controlKey(el);
                if (!key || !_defaults.hasOwnProperty(key)) return;
                var dv = _defaults[key];
                if (el.tagName && el.tagName.toLowerCase() === 'details') {
                  el.open = _isTruthyParam(dv);
                  try { el.dispatchEvent(new Event('toggle')); } catch (e) {}
                  return;
                }
                if (el.tagName && el.tagName.toLowerCase() === 'select') {
                  el.value = String(dv || '');
                  try { el.dispatchEvent(new Event('change')); } catch (e) {}
                  return;
                }
                var t = (el.getAttribute('type') || '').toLowerCase();
                if (t === 'checkbox') {
                  el.checked = _isTruthyParam(dv);
                  try { el.dispatchEvent(new Event('change')); } catch (e) {}
                  return;
                }
              });

              // Restore tree toggles to their default expanded/collapsed state.
              try {
                var triNodes = document.querySelectorAll('[data-children-id]');
                triNodes.forEach(function(tg) {
                  var cid = tg.getAttribute('data-children-id');
                  if (!cid) return;
                  var defExp = (tg.getAttribute('data-default-expanded') === '1');
                  var cont = document.getElementById(cid);
                  if (cont) cont.style.display = defExp ? 'inline' : 'none';
                  tg.textContent = defExp ? '▼' : '▶';
                });
              } catch (e) {}

              // Restore snippets to default-collapsed.
              try {
                var snipDivs = document.querySelectorAll('span[id^="err_snip_"]');
                snipDivs.forEach(function(el) { el.style.display = 'none'; });
                var snipToggles = document.querySelectorAll('[onclick^="toggleErrorSnippet("]');
                snipToggles.forEach(function(tg) { tg.textContent = '▶ Snippet'; });
              } catch (e) {}

              // Commit-history specific: collapse expanded rows (GitHub/GitLab trees + docker details).
              // These are not part of the <pre> tree renderer, so we must reset them explicitly.
              try {
                // Docker details rows
                document.querySelectorAll('tr[id^="docker-row-"]').forEach(function(tr) {
                  tr.style.display = 'none';
                });
                // GitHub tree rows
                document.querySelectorAll('tr[id^="github-tree-row-"]').forEach(function(tr) {
                  tr.style.display = 'none';
                });
                // GitLab tree rows
                document.querySelectorAll('tr[id^="gitlab-tree-row-"]').forEach(function(tr) {
                  tr.style.display = 'none';
                });
                // Reset the toggle glyphs
                document.querySelectorAll('[id^="docker-toggle-"]').forEach(function(el) { el.textContent = '▶'; });
                document.querySelectorAll('[id^="github-tree-toggle-"]').forEach(function(el) { el.textContent = '▶'; });
                document.querySelectorAll('[id^="gitlab-tree-toggle-"]').forEach(function(el) { el.textContent = '▶'; });
              } catch (e) {}
            } finally {
              _restoring = false;
            }
          }
        } catch (e) {}
      },
      init: function() {
        _captureDefaults();
        var params = _parseParams();
        _applyToControlsFromParams(params);
        _applyTreeAndSnippetTogglesFromParams(params);
        _bindControlsToUrl();
      }
    };

    // Simple ready-queue so dashboard-specific scripts can run AFTER DashboardUrlState.init()
    // without relying on DOMContentLoaded handler registration order.
    window.__dashboardReady = window.__dashboardReady || { fired: false };
    window.__dashboardOnReadyQueue = window.__dashboardOnReadyQueue || [];
    window.dashboardOnReady = function(cb) {
      try {
        if (window.__dashboardReady && window.__dashboardReady.fired) {
          cb();
        } else {
          window.__dashboardOnReadyQueue.push(cb);
        }
      } catch (e) {}
    };

    document.addEventListener('DOMContentLoaded', function() {
      try { window.DashboardUrlState.init(); } catch (e) {}
      try {
        window.__dashboardReady.fired = true;
        var q = window.__dashboardOnReadyQueue || [];
        window.__dashboardOnReadyQueue = [];
        q.forEach(function(fn) { try { fn(); } catch (e) {} });
      } catch (e) {}
    });

    // ====================================================================================
    // Sleep/wake fault-tolerant "reload only if new file" checker (replaces meta refresh)
    //
    // Requirement:
    // - Poll periodically (configurable per page; default 30 seconds).
    // - Only reload when the underlying HTML file changed on the server (ETag / Last-Modified).
    // - Tolerate sleep/wake + transient disconnects (keep page; retry).
    //
    // Note: dashboard URLs often include query/hash for view state; we intentionally probe the
    // *path* only (same file), then reload the full current URL to preserve view state.
    // ====================================================================================
    (function() {
      var checkIntervalMs = {{ refresh_check_interval_ms | default(30000) }};
      var retryMs = 2000;
      var maxRetryMs = 60000;
      var retryTimer = null;
      var scheduledTimer = null;
      var lastTick = Date.now();
      var lastPathname = String(window.location && window.location.pathname || "");
      var lastEtag = "";
      var lastLastModified = "";
      var lastContentLength = "";
      var hasBaseline = false;

      // Intentionally do NOT compare Last-Modified to generated_time on load.
      // That heuristic can cause reload loops when time parsing differs or clocks drift.

      function _ensureBanner() {
        var el = document.getElementById('auto-refresh-banner');
        if (el) return el;
        el = document.createElement('div');
        el.id = 'auto-refresh-banner';
        el.className = 'auto-refresh-banner';
        el.innerHTML = '<div class="msg" id="auto-refresh-banner-msg"></div>' +
                       '<div style="display:flex; gap:8px; align-items:center;">' +
                       '<button id="auto-refresh-banner-retry" type="button">Retry now</button>' +
                       '</div>';
        document.body.appendChild(el);
        var btn = document.getElementById('auto-refresh-banner-retry');
        if (btn) btn.addEventListener('click', function() { _attemptReloadSoon(0); });
        return el;
      }

      function _setBanner(msg) {
        try {
          var el = _ensureBanner();
          var msgEl = document.getElementById('auto-refresh-banner-msg');
          if (msgEl) msgEl.textContent = String(msg || '');
          el.style.display = 'inline-flex';
        } catch (e) {}
      }

      function _hideBanner() {
        try {
          var el = document.getElementById('auto-refresh-banner');
          if (el) el.style.display = 'none';
        } catch (e) {}
      }

      function _sleepAwareTick() {
        var now = Date.now();
        var delta = now - lastTick;
        lastTick = now;
        // If timers were paused (sleep), re-check quickly after wake.
        if (delta > 30000) {
          _attemptCheckSoon(250);
        }
      }

      function _buildProbeUrl() {
        try {
          // Probe the file at the current path (ignore query/hash which are UI state).
          var u = new URL(window.location.origin + window.location.pathname);
          u.searchParams.set('__probe', String(Date.now()));
          return u.toString();
        } catch (e) {
          return String(window.location.href || '');
        }
      }

      function _probeOnce() {
        var url = _buildProbeUrl();
        // Prefer HEAD (cheap), but fallback to GET if the server doesn't allow it.
        return fetch(url, { method: 'HEAD', cache: 'no-store', credentials: 'same-origin' })
          .then(function(resp) {
            if (resp && (resp.status === 405 || resp.status === 501)) {
              return fetch(url, { method: 'GET', cache: 'no-store', credentials: 'same-origin' })
                .then(function(r2) { return r2; })
                .catch(function() { return null; });
            }
            return resp;
          })
          .catch(function() { return null; });
      }

      function _attemptCheckSoon(ms) {
        try { if (retryTimer) window.clearTimeout(retryTimer); } catch (e) {}
        retryTimer = window.setTimeout(_attemptCheck, Math.max(0, Number(ms || 0)));
      }

      function _scheduleNextNormalCheck() {
        try { if (scheduledTimer) window.clearTimeout(scheduledTimer); } catch (e) {}
        scheduledTimer = window.setTimeout(function() { _attemptCheckSoon(0); }, checkIntervalMs);
      }

      function _attemptCheck() {
        // If the URL changed (SPA-style or manual), reset validators.
        try {
          var pn = String(window.location && window.location.pathname || "");
          if (pn && pn !== lastPathname) {
            lastPathname = pn;
            lastEtag = "";
            lastLastModified = "";
            lastContentLength = "";
          }
        } catch (e) {}

        // Don't churn hidden tabs; we'll refresh when visible again.
        if (document.hidden) {
          _scheduleNextNormalCheck();
          return;
        }
        // If we know we're offline, keep the page and retry.
        try {
          if (navigator && navigator.onLine === false) {
            _setBanner('Disconnected (offline). Keeping this page; retrying…');
            _scheduleNextNormalCheck();
            return;
          }
        } catch (e) {}

        _probeOnce().then(function(resp) {
          if (!(resp && resp.ok)) {
            _setBanner('Disconnected (server unreachable). Keeping this page; retrying…');
            _scheduleNextNormalCheck();
            return;
          }

          _hideBanner();
          retryMs = 2000;

          // Compare validators.
          var etag = '';
          var lm = '';
          var cl = '';
          try { etag = String(resp.headers.get('etag') || ''); } catch (e) { etag = ''; }
          try { lm = String(resp.headers.get('last-modified') || ''); } catch (e) { lm = ''; }
          try { cl = String(resp.headers.get('content-length') || ''); } catch (e) { cl = ''; }

          var changed = false;
          if (hasBaseline) {
            if (etag && lastEtag && etag !== lastEtag) changed = true;
            if (!changed && lm && lastLastModified && lm !== lastLastModified) changed = true;
            if (!changed && cl && lastContentLength && cl !== lastContentLength) changed = true;
          }

          // Update stored validators (even if empty, keep best-effort).
          if (etag) lastEtag = etag;
          if (lm) lastLastModified = lm;
          if (cl) lastContentLength = cl;
          hasBaseline = true;

          if (changed) {
            try { window.location.reload(); } catch (e) {}
            return;
          }
          _scheduleNextNormalCheck();
        });
      }

      // Start normal check loop.
      _scheduleNextNormalCheck();

      // Wake / connectivity helpers.
      window.setInterval(_sleepAwareTick, 5000);
      window.addEventListener('online', function() { _attemptCheckSoon(250); });
      document.addEventListener('visibilitychange', function() {
        if (!document.hidden) _attemptCheckSoon(250);
      });
    })();
  })();
  </script>

  {% block tail_script %}{% endblock %}
</body>
</html>


